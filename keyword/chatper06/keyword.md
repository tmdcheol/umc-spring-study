### 지연로딩과 즉시로딩의 차이

지연로딩은 위의 설명과 일치합니다. Lazy 옵션을 주어서 실제로 객체의 “필드” 에 접근할 때 그 때 쿼리가 나가는 방식으로 동작합니다. 물론 fetch join을 사용하면 미리 join하여 가져옵니다.

즉시로딩은 연관이 있는 객체를 조회할 때 eager로 설정 되어있는 객체들을 모두 타고 들어가서 전부 join을 한 뒤에 데이터를 가져옵니다. eager 설정은 예상치 못한 쿼리가 돌아갈 가능성이 있기 때문에 일단 lazy로 설정하고 필요할 경우 fetch join을 사용하는 방식이 선호된다고 합니다.

### Fetch Join
Fetch Join이 바로 N+1 문제를 해결할 수 있는 해결책 중 하나가 되는 것입니다.
JPQL의 Fetch Join을 사용한다면, 조회할 때 미리 객체들을 join을 해서 가져오기 때문에
Lazy로 설정을 했더라도 N+1 문제가 발생하지 않습니다.

### @EntityGraph
Fetch Join과 함께 N+1 문제를 해결할 수 있는 다른 방식입니다.

### JPQL
JPA의 객체지향 쿼리 언어로 엔터티 객체를 대상으로 작성합니다. SQL로 결국 번역되어 데이터베이스에 쿼리가 보내지게 됩니다. SQL과 다른 점은 엔터티를 대상으로 쿼리를 작성할 수 있는 것입니다.

### QueryDSL
JPA를 사용하면 동적쿼리를 작성하는데 어려움이 존재합니다. 이를 해결하기 위해서 사용하는 방식이고 Spring 공식스펙은 아니며, 외부 라이브러리입니다. 따라서 처음 사용할 때 설정이 다소 까다로운 면이 있습니다.

Java 코드를 통해서 동적으로 쿼리를 작성할 수 있습니다. 여기서 오는 아주 큰 이점이 있는데 컴파일 시점에 오류를 방지할 수 있다는 것입니다.